# Challenge 3 - Microservice abstractions with Kubernetes Operators 

Kubernetes operators are applications that are using the Kubernetes API to create auto-updating, self-monitoring and self-healing infrastructure and applications. There are used to supplement the Kubernetes resources we use day-to-day. Operators are defining Custom Resources and work on them. As such, they use the [Custom Resource Definition extension of Kubernetes](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/). The advantage of using Kubernetes custom resources is that they can be managed in the same way as your other Kubernetes resources.

Operators usually read their custom resources and build or modify Kubernetes resources based on the state of the custom resources. One example are database operators which manage database systems in Kubernetes. 

In this challenge, we will built a microservice operator that abstracts the Kubernetes resources that are needed to deploy a microservice to Kubernetes. 

## Building a microservice operator (120 min)

This operator aims to make operations a lot easier by abstracting the usual
`Deployment`, `Service` and `ConfigMap` definitions using a simple and unified
`Microservice` custom resource. The operator will then manage the underlying
Kubernetes resources automatically.

For the operator, we need to define the following things:
- generate the Operator skeleton as we will use the Operator SDK which generates a lot of boilerplate code around running a operator and interacting with the Kubernetes API 
- define a custom resource definition which is the specification of a `Microservice`. For simplification, it will define only a small subset of the possible configuration. We need properties for the number of replicas, the image, which ports should be exposed and the service type. Additional properties are for now out of scope but can be added rather easily.
- implement the reconcile loop. The reconcile loop defines the actions which the operator need to do when the `Microservice` resource is created, modified or deleted 

For the scope of this challenge, the operator only does creation and
deletion of a deployment and service objects and omit ConfigMap creation.

A sample custom resource of a microservice will look like this:
```yaml
apiVersion: apps.example.com/v1
kind: Microservice
metadata:
  name: microservice-test
  labels:
    app: nginx
spec:
  replicas: 2
  image: nginx:1.17.6
  ports:
    - 80
  serviceType: LoadBalancer
```

### Installing the Operator SDK CLI

To generate the Operator Skeleton, we first need to install the Operator SDK CLI. 

On Mac you can use Homebrew and install it using `brew install operator-sdk`.
On other systems follow this guide: https://v1-2-x.sdk.operatorframework.io/docs/installation/install-operator-sdk/#install-from-github-release

### Creating the Operator Skeleton

To create the operator skeleton, we will use the Operator SDK.

```bash
mkdir k8s-microservice-operator
cd k8s-microservice-operator

# we will use as domain example.com but you can replace it if you like
# API groups will be <group>.example.com
operator-sdk init --domain example.com --repo k8s-microservice-operator

# now we create our API for the Microservice custom resource
operator-sdk create api --group apps --version v1 --kind Microservice --resource --controller
```

### Creating the Microservice CRD

Next, we need to defined the CRD specification for the Microservice resource.

You find the CRD specification after you generated the API with the `operator-sdk` command in the previous section, in the `api` folder under `microservice_types.go`. In this file, only change the MicroserviceSpec type as the other types are autogenerated. 

You need to modify the file with the following code:
```golang
// MicroserviceSpec defines the desired state of Microservice
type MicroserviceSpec struct {
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
	// Important: Run "make" to regenerate code after modifying this file

	// +kubebuilder:validation:Minimum=0
	// Replicas is the number of replicas for the microservice deployment
	Replicas int32 `json:"replicas,omitempty"`

	// Image is the Docker image and tag to use for the microservice deployment
	Image string `json:"image,omitempty"`

	// Ports is the list of HTTP container ports for the microservice deployment
	Ports []int32 `json:"ports"`

	// ServiceType is the service type to use for the microservice service
	ServiceType string `json:"serviceType,omitempty"`
}
```

Note the `+kubebuilder` annotations. These can be used to add configuration for the code generation, in our case we configured a validation that replicas should at least have 0 replicas. You can read [here](https://sdk.operatorframework.io/docs/building-operators/golang/references/openapi-validation/) more about validation.

Once done, run `make generate` and `make manifests`. This is necessary to regenerate the custom resource code and deployable manifests. 

### Implement Reconcile Loop

Finally, the reconcile loop needs to be implemented to apply the changes required to
the current resource state. The reconcile loop is in the controller generated for for the API called `microservice_controller.go`. There in the `SetupWithManager` function, it already watches for the `Microservice` resource.

Add the following imports (some are already there, some are needed for the reconcile loop code we add below):
```golang
import (
	"context"

	v1 "k8s.io/api/apps/v1"
	apiv1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"

	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	appsv1 "github.com/qaware/k8s-microservice-operator/api/v1"
)
```

Modify the reconcile loop by changing the `Reconcile` function:
```golang
...
// RBAC annotations necessary for the operator service account to access the resources we want to create/listen to
//+kubebuilder:rbac:groups=apps.example.com,resources=microservices,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=apps.example.com,resources=microservices/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=apps.example.com,resources=microservices/finalizers,verbs=update
//+kubebuilder:rbac:groups="apps",resources=deployments,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="",resources=services,verbs=get;list;watch;create;update;patch;delete

// Reconcile loop to apply relevant changes to K8s
func (r *MicroserviceReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	// lookup the Microservice instance for this reconcile request
  microservice := &appsv1.Microservice{}
  // build logger using controller-runtime package
  logger := ctrl.Log.WithName("controllers").WithName("Microservice").WithValues("microservice", req.NamespacedName)

  err := r.Get(ctx, req.NamespacedName, microservice)
  if err != nil {
    if errors.IsNotFound(err) { // import "k8s.io/apimachinery/pkg/api/errors"
        logger.Info("Microservice resource not found. Ignoring.")
        // delete all associated resources created for the microservice
        return ctrl.Result{}, nil
    }
    logger.Error(err, "Failed to get Microservice.")
    return ctrl.Result{}, err
  }

  logger.Info("Reconcile Microservice.")
  // add the update the associated service, deployment, ...
  deployment := &v1.Deployment{} // fill the structure with the field of our Microservice resource; your IDE can help you with filling the structure

  // create the deployment resource
  err = r.Client.Create(context.TODO(), deployment, &client.CreateOptions{})
  if err != nil {
    logger.Error(err, "error with deployment resource")
  }

  service := &apiv1.Service{} // fill the structure with the field of our Microservice resource; your IDE can help you with filling the structure

  // create the service resource
  err = r.Client.Create(context.TODO(), service, &client.CreateOptions{})
  if err != nil {
    logger.Error(err, "error with service resource")
  }

  return ctrl.Result{}, nil
}
```

If you are stuck, you can find the solution for the reconcile loop repository under `k8s-microservice-operator/controllers/microservice_controller.go`. Warning though, the solution is generated using an older operator sdk version.

### Install and deploy the operator to Kubernetes

To build and deploy the operator, we can use the makefile from the Operator SDK.   
Ensure that minikube is still running. 

Run the following commands for deploying the operator:
```bash
# installs custom resource definitions
make install

# to run the operator in minikube we need to configure the docker daemon to use the minikube context
eval $(minikube -p minikube docker-env)

# builds docker image and deploys operator
make IMG=controller:v1 docker-build deploy
```

We will also need to create a sample microservice custom resource:
```yaml
apiVersion: apps.example.com/v1
kind: Microservice
metadata:
  name: microservice-sample
  labels:
    app: nginx
spec:
  replicas: 3
  image: nginx:1.17.6
  ports:
    - 80
  serviceType: NodePort
```
Store the contents in microservice.yaml and deploy it with `kubectl apply -f microservice.yaml`.

Check the pods created by the microservice operator using `kubectl get po` and the service with `kubectl get svc`.